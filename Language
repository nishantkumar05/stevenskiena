

- HOW TO PARSE C/C++ SYNTAX
  - CLOCKWISE/SPIRAL RULE - http://c-faq.com/decl/spiral.anderson.html
  - move clockwise and stop at either '[' or '(' or ';'. When ';' is encountered your continue looping around it until we finish encountering leftmost declaration syntax
  - Replace following with english sentences 
    - [X] or [] = array of size X of or array of undefined size of ...
    - ( = function accepting ...
    - * = pointer to ...

- RVALUES AND LVALUES
  - http://stackoverflow.com/questions/2145030/are-all-temporaries-rvalues-in-c
    rvalue or lvalue is property of expression not an object!


- OPERATORS
  - sizeof(a) = 8 (not 2) where, int a[] = {3,4}; , because sizeof is size of object's repersentation
  - sizeof always use parenthesis around sizeof to be safe becaues sizeof 3/sizeof int; fails because its ambiguous -> its sizeof (3/sizeof(int) or sizeof(3)/sizeof(int)?


- QUALIFIERS
  A- Types of qualifiers
     - Storage = static, extern, thread_local, global
     - Type = cv-qualifiers (const and volatile), mutable (const function can still modify values internally)

  B- volatile do-away with optimizations because every access (read, write, member function call) of volatile object (e.g volatile std::string s;) is 'treated' as changing state of object

- INITIALIZATION (c++11)
  http://en.cppreference.com/w/cpp/language/initialization
  A- Syntaxically 3 types of initilization: (expr), =expr or {expr}
  B- Types of initialization (based on syntax):
     -> zero-initialization = global, static variables have zero by default
     -> Empty-value-initialization = std::string s{}/s() initialized with empty values
     -> Temporary-copy-initialization = std::String s = "hello"; (almost always optmized by compiler)
     -> List-initialization = std::string s = {'a', 'b', 'c'};
     -> Aggregate-initialization = array or class/struct/union initialzed with braces. T a = {b1, b2, b3}; where T is class that looks like struct
  C- curly-brace-init was introduced in c++11 standard

  D- copy-elision = prolific compiler optimization to avoid creating temporary object and then copy-constructor call

  E- int&& t = 10 + 4;

- FUNCTIONS

- ARRAYS AND POINTERS:
  - Decay of array to pointer
    int a[10];
    int *p = a; //array a decay into pointer to first element i.e. &a[0]
  - Variable declaration VS variable usage:
     - Size of array must be know during declaration i.e. a[][] ={{2,2},{2,2}}; fails unless a[][2]
     - You can use pointers and arrays interchangeably during usage but not in declaration
  - only similarity between pointer and arrays is pointer arithmetic and array subscript address calculation.
  - Difference between pointer and arrays is that (char *p = "a string" vs char a[] = "array string") storage location
  - 2D array
    Passing 2D array require size of column because decay of array into pointers doesnt happen recursively only for first entry.
    And you need array size to calculate innermost elements
  - Passing array to function by reference?
      foo(int a[]) == foo(int (&a)[]) , because arrays are always passed by reference in c/c++
