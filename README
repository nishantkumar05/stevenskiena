ALGORITHMS STEVEN SKIENA
------------------------

You want to know these things about algorithms:
- What problem does algorithm solves? 
- And how efficiently? Best, average and worst case time complexities?
- Use cases of algorithm. Which algorithm best in which case


How to solve problem?
- What data structure to use? What would make it efficient?
- Know algorithm basics (practice coding to get better as the cliche goes)
- Make sure algorithms can be jotted down in 45 mins plain (?)




Chapter 1: Correctness and efficiency
-------------------------------------
Decreasing order of efficiency

O(1) = constant time
O(log n) = logarithmic time
O(n) = linear time (polynomial with k = 1)
O(n log n) = linearithmic 
O(n^2) = polynomial time
O(2^n) = exponential time
O(n!) = combination

Chapter 2: Data structure and sorting
-------------------------------------

A- Factors influencing algorithm choice
   Complexity
   - Runtime complexity (Big-O notation)
   - Space complexity
     = In-place
     = Algos with locality of reference in L1 or L2 cache

   Input data
   - Data size
   - Data structure in which data is stored
   - data distribution (Insertion sort is better than selection if data is already sorted)


B- Stable sort?
   Any sorting algorithm that doesn't change input data if it considers two items as equal.
   
   Sort (2,blue) , (3,red) , (4,red), (9,green), (1,red) by colors in red > blue > green order. 
   Stable sort in this case will make syre that items (3,red) and (4,red) doesnt change in final output


C- Hash tables
   - Hash function = fun that maps input of some size to some relatively smaller fixed size value.
   - Hash function properties:
       - Deterministic - always works for any input size in polynomial time 
       - Continuity 
       - Output length
       - Uniformity
       - Non-collision (checksum) - 2 diff i/p cann't generate same hash else checksum is false +ve
       - non-reversible hash (cryptographics)
   - Hash uses: Cryptographic hash, checksum 
   - To limit hash to some limit divide it by some prime

Chapter 4: Graph
-----------------

A- Why does BFS give us shortest path between root (starting node of bfs traversal) and x?
   - because at every step of bfs traversal we store shortest path in parents[] array (if x discovers y then
     parent[y] = x). Its shortest because in bfs we visit all siblings to x first before moving forward so y has
     smallest distance between itself and x.

Chapter 3: Breaking problems down (Dynamic Programming)
-------------------------------------------------------
A) Dynamic program applied to problems which
   - Tries to minimize or maximize 'something'
   - support principle of optimiality: i.e. removing an element doesnt alter state of the problem
   - Seems like NP-complete problem
   - NP-completeness is bound by some condition
